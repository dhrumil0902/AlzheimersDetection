# -*- coding: utf-8 -*-
"""CFC_Transform_Final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_ES-Pjd1Zp8KP7Ene_ne9JituHChuRGx
"""

#!pip install pywavelets

#!pip install mne

#from google.colab import drive
#drive.mount('/content/drive')

import os
import json
import pandas as pd
import numpy as np
import mne
import pywt
import math
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator
import time
import cv2
from scipy.signal import iirnotch, butter, filtfilt
from mne.io import read_raw_eeglab

# Paths and constants
DATA_PATH = "../data/ds004504"  # Adjust this to your Google Drive path
LABEL_PATH = "data/participants.tsv"
NEMAR_PADDING_LENGTH_SECONDS = 5
SAMPLING_FREQUENCY_HZ = 500
NEMAR_PADDING_LENGTH_SAMPLES = NEMAR_PADDING_LENGTH_SECONDS * SAMPLING_FREQUENCY_HZ
SAMPLING_PERIOD_SECONDS = 1 / SAMPLING_FREQUENCY_HZ
EPOCH_LENGTH_SECONDS = 6
EPOCH_LENGTH_SAMPLES = int(EPOCH_LENGTH_SECONDS * SAMPLING_FREQUENCY_HZ)
N_CHANNELS = 19
N_SUBJECTS = 88
N_EPOCHS = 5
N_SEGMENTS = 6
SEGMENT_LENGTH_SAMPLES = int(EPOCH_LENGTH_SAMPLES / N_SEGMENTS)
ALPHA_FREQUENCIES = (4, 8, 0.1)
GAMMA_FREQUENCIES = (55, 75, 1)
N_ALPHA = int((ALPHA_FREQUENCIES[1] - ALPHA_FREQUENCIES[0]) / ALPHA_FREQUENCIES[2])
N_GAMMA = int((GAMMA_FREQUENCIES[1] - GAMMA_FREQUENCIES[0]) / GAMMA_FREQUENCIES[2])
CWT_B = 6
CWT_C = 0.8125
CHANNEL_NAMES = ['Fp1', 'Fp2', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4', 'O1', 'O2', 'F7', 'F8', 'T3', 'T4', 'T5', 'T6', 'Fz', 'Cz', 'Pz']

#from ref [26] of thesis
N_PHASE_BINS = 18
H_MAX = math.log2(N_PHASE_BINS)


# Function to read participant group from label file
def get_subject_group(subject_str):
    participant_id = "sub-" + subject_str
    participants_df = pd.read_csv(LABEL_PATH, sep="\t")
    participant_row = participants_df[participants_df['participant_id'] == participant_id]
    assert not participant_row.empty
    return participant_row['Group'].values[0]

# Function to calculate CWT scales based on frequencies
def get_cwt_scales(min_freq, max_freq, step_size):
    frequencies = np.arange(min_freq, max_freq, step_size)
    scales = 1 / (frequencies * SAMPLING_PERIOD_SECONDS)
    return scales

def get_phase_bin(phase_rads):
    phase_rads = np.where(phase_rads == math.pi, -math.pi, phase_rads)
    assert np.all((phase_rads >= -math.pi) & (phase_rads < math.pi))
    bin_indices = ((phase_rads + math.pi) / (2 * math.pi) * N_PHASE_BINS).astype(int)
    assert np.all((bin_indices >= 0) & (bin_indices < N_PHASE_BINS))
    return bin_indices

def plot_phases_and_amplitudes(phases, amplitudes, alpha_scales, gamma_scales):
    # Heatmap for phases
    plt.subplot(2, 1, 1)
    plt.title("Alpha Frequency Phases (Heatmap)")
    plt.imshow(phases, aspect='auto', cmap='twilight', extent=[0, SEGMENT_LENGTH_SAMPLES, alpha_scales[-1], alpha_scales[0]])
    plt.colorbar(label='Phase (radians)')
    plt.xlabel("Time (samples)")
    plt.ylabel("Scales")

    # Heatmap for amplitudes
    plt.subplot(2, 1, 2)
    plt.title("Gamma Frequency Amplitudes (Heatmap)")
    plt.imshow(amplitudes, aspect='auto', cmap='viridis', extent=[0, SEGMENT_LENGTH_SAMPLES, gamma_scales[-1], gamma_scales[0]])
    plt.colorbar(label='Amplitude')
    plt.xlabel("Time (samples)")
    plt.ylabel("Scales")

    plt.tight_layout()
    plt.show()

def apply_notch_filter(signal, fs, freq=60, quality_factor=30):
    b, a = iirnotch(freq, quality_factor, fs)
    return filtfilt(b, a, signal)

# def bandpass_filter(signal, lowcut, highcut, fs, order=4):
#     nyquist = 0.5 * fs
#     low = lowcut / nyquist
#     high = highcut / nyquist
#     b, a = butter(order, [low, high], btype="band")
#     return filtfilt(b, a, signal)

# Apply CWT and extract phase and amplitude
def apply_cwt(signal, scales, wavelet_name='cmor'):
    coeffs, frequencies = pywt.cwt(signal, scales, wavelet_name, sampling_period=SAMPLING_PERIOD_SECONDS)
    return coeffs, frequencies

def extract_phase_amplitude(coeffs):
    phase = np.angle(coeffs)  # Extract phase
    amplitude = np.abs(coeffs)  # Extract amplitude
    return phase, amplitude

# PAC calculation helper functions
def calculate_pac(theta_phase, gamma_amplitude, nbins=18):
    # Bin the theta phases
    phase_bins = np.linspace(-np.pi, np.pi, nbins + 1)
    # Digitize the theta_phase array to determine which bin each phase falls into
    bin_indices = np.digitize(theta_phase, phase_bins) - 1  # `-1` to match zero-based indexing
    amplitude_means = np.zeros(nbins)

    # Calculate the mean gamma amplitude for each bin
    for i in range(nbins):
        # Select gamma_amplitude values in the current bin and calculate the mean
        bin_amplitudes = gamma_amplitude[bin_indices == i]
        amplitude_means[i] = np.mean(bin_amplitudes) if bin_amplitudes.size > 0 else 0

    # Normalize to create a probability distribution
    amplitude_prob_dist = amplitude_means / np.sum(amplitude_means)
    return amplitude_prob_dist

def calculate_modulation_index(pac_distribution):
    H = -np.sum(pac_distribution * np.log(pac_distribution + 1e-8))
    H_max = np.log(len(pac_distribution))
    modulation_index = (H_max - H) / H_max
    return modulation_index

# Main processing function for gPAC matrix generation and plotting
def generate_gpac_plots():
    alpha_scales = get_cwt_scales(ALPHA_FREQUENCIES[0], ALPHA_FREQUENCIES[1], ALPHA_FREQUENCIES[2])
    gamma_scales = get_cwt_scales(GAMMA_FREQUENCIES[0], GAMMA_FREQUENCIES[1], GAMMA_FREQUENCIES[2])
    cwt_scales = np.concatenate((alpha_scales, gamma_scales))

    for subject_id in range(51, 53):
        subject_str = f"{subject_id:03}"
        if get_subject_group(subject_str) == "F":  # Skip FTD group
            continue

        subject_path = f"{DATA_PATH}/sub-{subject_str}/eeg/sub-{subject_str}_task-eyesclosed_eeg.set"
        json_path = f"{DATA_PATH}/sub-{subject_str}/eeg/sub-{subject_str}_task-eyesclosed_eeg.json"
        epochs = read_raw_eeglab(subject_path)

        json_file =  open(json_path, 'r');
        json_data = json.load(json_file)
        recording_duration = json_data.get("RecordingDuration")
        subject_raw = mne.io.read_raw_eeglab(subject_path, preload=True)

        subject_data = subject_raw.get_data()
        assert(subject_data.shape == (N_CHANNELS, int(SAMPLING_FREQUENCY_HZ * recording_duration)))

        d_epoch_start_time_sec = (recording_duration - 2 * NEMAR_PADDING_LENGTH_SECONDS - EPOCH_LENGTH_SECONDS) / (N_EPOCHS - 1)
        d_epoch_start_time_sample = int(d_epoch_start_time_sec * SAMPLING_FREQUENCY_HZ)

        fig, axes = plt.subplots(2, 3, figsize=(15, 10))  # Create 2x3 grid for six segments
        for epoch_id in range(N_EPOCHS):
            start_sample = NEMAR_PADDING_LENGTH_SAMPLES + epoch_id * d_epoch_start_time_sample
            epoch = subject_data[:, start_sample : (start_sample + EPOCH_LENGTH_SAMPLES)]
            assert(epoch.shape == (N_CHANNELS, EPOCH_LENGTH_SAMPLES))
            for segment_id in range(N_SEGMENTS):
                start_sample = segment_id * SEGMENT_LENGTH_SAMPLES
                end_sample = start_sample + SEGMENT_LENGTH_SAMPLES
                segment = epoch[:, start_sample:end_sample]

                filtered_segment = np.zeros_like(segment)
                for channel_id in range(N_CHANNELS):
                    notch_filtered_signal = apply_notch_filter(segment[channel_id, :], SAMPLING_FREQUENCY_HZ)

                # Placeholder PAC matrix
                pac_matrix = np.zeros((len(alpha_scales), len(gamma_scales)))

                # Calculate PAC for each channel and aggregate to gPAC
                for channel_id in range(N_CHANNELS):
                    segment_channel = segment[channel_id, :]

                    '''
                    #notch filter
                    b_notch, a_notch = iirnotch(w0=CFC_NOTCH_FREQUENCY / (sampling_freq / 2), Q=CFC_NOTCH_QUALITY_FACTOR)
                    segment_channel_notch = filtfilt(b_notch, a_notch, segment_channel)

                    #filter to the alpha and gamma ranges
                    b_alpha, a_alpha = butter(CFC_BAND_ORDER, [ALPHA_FREQUENCIES[0] / (0.5 * sampling_freq), ALPHA_FREQUENCIES[1] / (0.5 * sampling_freq)], btype='band')
                    segment_channel_alpha = filtfilt(b_alpha, a_alpha, segment_channel_notch)
                    #this fails for OSF bc upper limit of bandpass range exceeds Nyquist freq (64Hz)
                    b_gamma, a_gamma = butter(CFC_BAND_ORDER, [GAMMA_FREQUENCIES[0] / (0.5 * sampling_freq), min(GAMMA_FREQUENCIES[1], sampling_freq / 2 - 1e-6) / (0.5 * sampling_freq)], btype='band')
                    segment_channel_gamma = filtfilt(b_gamma, a_gamma, segment_channel_notch)
                    '''

                    coefs, _ = apply_cwt(segment_channel, cwt_scales, f"cmor{CWT_B}-{CWT_C}")

                    alpha_coefs = coefs[:len(alpha_scales), :]
                    gamma_coefs = coefs[len(alpha_scales):, :]

                    alpha_phase, _ = extract_phase_amplitude(alpha_coefs)
                    _, gamma_amplitude = extract_phase_amplitude(gamma_coefs)

                    min_time_points = min(alpha_phase.shape[1], gamma_amplitude.shape[1])
                    alpha_phase = alpha_phase[:, :min_time_points]
                    gamma_amplitude = gamma_amplitude[:, :min_time_points]

                    for a_idx, theta_phase in enumerate(alpha_phase):
                        for g_idx, gamma_amp in enumerate(gamma_amplitude):
                            pac_dist = calculate_pac(theta_phase, gamma_amp)
                            pac_matrix[a_idx, g_idx] += calculate_modulation_index(pac_dist)

                pac_matrix /= N_CHANNELS  # Average across channels

                flipped_pac_matrix = np.flip(pac_matrix.T, axis=0)

                # Plot the flipped PAC matrix for the segment
                ax = axes[segment_id // 3, segment_id % 3]
                cax = ax.imshow(flipped_pac_matrix,
                                extent=[ALPHA_FREQUENCIES[0], ALPHA_FREQUENCIES[1], GAMMA_FREQUENCIES[0], GAMMA_FREQUENCIES[1]],
                                aspect='auto', origin='lower', cmap='viridis')
                ax.set_title(f"Segment {segment_id}")
                ax.set_xlabel("Theta Phase Frequency (Hz)")
                ax.set_ylabel("Gamma Amplitude Frequency (Hz)")
                fig.colorbar(cax, ax=ax, label="PAC Modulation Index")

            break  # Process one epoch per subject for demonstration
        plt.tight_layout()
        plt.show()
        break  # Process one subject for demonstration

# Run the main function
generate_gpac_plots()

import numpy as np
import matplotlib.pyplot as plt

def generate_synthetic_signal(
    sampling_frequency,
    duration_seconds,
    alpha_frequency,
    gamma_frequency,
    modulation_depth=0.5
):
    """
    Generate a synthetic EEG-like signal with PAC.

    Parameters:
    - sampling_frequency: int, Sampling frequency in Hz.
    - duration_seconds: float, Duration of the signal in seconds.
    - alpha_frequency: float, Frequency of the low-frequency phase component in Hz.
    - gamma_frequency: float, Frequency of the high-frequency amplitude component in Hz.
    - modulation_depth: float, Amplitude modulation depth (0 to 1).

    Returns:
    - signal: np.ndarray, Generated synthetic signal.
    """
    t = np.linspace(0, duration_seconds, int(sampling_frequency * duration_seconds), endpoint=False)

    # Generate alpha phase signal
    alpha_phase = np.sin(2 * np.pi * alpha_frequency * t)

    # Modulate gamma amplitude
    gamma_carrier = np.sin(2 * np.pi * gamma_frequency * t)
    modulated_gamma = (1 + modulation_depth * alpha_phase) * gamma_carrier

    return modulated_gamma


def verify_cfc_script():
    # Synthetic signal parameters
    duration = 2  # seconds
    sampling_frequency = SAMPLING_FREQUENCY_HZ  # 500 Hz
    alpha_frequency = 6  # Hz (in the alpha band)
    gamma_frequency = 80  # Hz (in the gamma band)
    modulation_depth = 0.5  # Depth of amplitude modulation

    # Generate synthetic EEG-like signal
    synthetic_signal = generate_synthetic_signal(
        sampling_frequency, duration, alpha_frequency, gamma_frequency, modulation_depth
    )

    # Plot the synthetic signal
    plt.figure(figsize=(10, 4))
    plt.plot(np.linspace(0, duration, len(synthetic_signal)), synthetic_signal)
    plt.title("Synthetic EEG-like Signal with PAC")
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude")
    plt.grid(True)
    plt.show()

    # Compute CWT scales for alpha and gamma bands
    alpha_scales = get_cwt_scales(ALPHA_FREQUENCIES[0], ALPHA_FREQUENCIES[1], ALPHA_FREQUENCIES[2])
    gamma_scales = get_cwt_scales(GAMMA_FREQUENCIES[0], GAMMA_FREQUENCIES[1], GAMMA_FREQUENCIES[2])

    # Apply CWT to extract coefficients
    alpha_coefs, _ = apply_cwt(synthetic_signal, alpha_scales, wavelet_name=f"cmor{CWT_B}-{CWT_C}")
    gamma_coefs, _ = apply_cwt(synthetic_signal, gamma_scales, wavelet_name=f"cmor{CWT_B}-{CWT_C}")

    # Extract phases (alpha) and amplitudes (gamma)
    alpha_phase, _ = extract_phase_amplitude(alpha_coefs)
    _, gamma_amplitude = extract_phase_amplitude(gamma_coefs)

    # Ensure both arrays have the same time dimension
    min_time_points = min(alpha_phase.shape[1], gamma_amplitude.shape[1])
    alpha_phase = alpha_phase[:, :min_time_points]
    gamma_amplitude = gamma_amplitude[:, :min_time_points]

    # Initialize PAC matrix
    pac_matrix = np.zeros((len(alpha_scales), len(gamma_scales)))

    # Calculate PAC matrix
    for a_idx, theta_phase in enumerate(alpha_phase):
        for g_idx, gamma_amp in enumerate(gamma_amplitude):
            pac_dist = calculate_pac(theta_phase, gamma_amp)
            pac_matrix[a_idx, g_idx] = calculate_modulation_index(pac_dist)

    # Flip PAC matrix for proper visualization
    flipped_pac_matrix = np.flip(pac_matrix.T, axis=0)

    # Plot PAC matrix
    plt.figure(figsize=(8, 6))
    plt.imshow(
        flipped_pac_matrix,
        extent=[ALPHA_FREQUENCIES[0], ALPHA_FREQUENCIES[1], GAMMA_FREQUENCIES[0], GAMMA_FREQUENCIES[1]],
        aspect='auto',
        origin='lower',
        cmap='viridis'
    )
    plt.colorbar(label="PAC Modulation Index")
    plt.title("PAC Matrix - Synthetic Signal")
    plt.xlabel("Theta Phase Frequency (Hz)")
    plt.ylabel("Gamma Amplitude Frequency (Hz)")
    plt.show()

    # Plot phases and amplitudes
    plot_phases_and_amplitudes(alpha_phase, gamma_amplitude, alpha_scales, gamma_scales)

    print("CFC script verification complete.")

# Call the verification function
verify_cfc_script()