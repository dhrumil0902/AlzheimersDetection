# -*- coding: utf-8 -*-
"""CFC_Transform_Overlapped

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/174lu_dNxc6m4R7plYkhfnBJWYo1vElbp
"""

!pip install pywavelets

!pip install mne

from google.colab import drive
drive.mount('/content/drive')

import os
import json
import pandas as pd
import numpy as np
import mne
import pywt
import math
import matplotlib.pyplot as plt
from scipy.signal import iirnotch, filtfilt

# Paths and constants
DATA_PATH = "/content/drive/MyDrive/ds004504"  # Adjust this to your Google Drive path
LABEL_PATH = "/content/drive/MyDrive/participants.tsv"
#SAVE_PATH_NPY = "/content/drive/MyDrive/CFC_Transformed_v2_npy"
SAVE_PATH_PNG = "/content/drive/MyDrive/CFC_Transformed_v2_overlap_images"

# Create directories if they don't exist
#os.makedirs(SAVE_PATH_NPY, exist_ok=True)
os.makedirs(SAVE_PATH_PNG, exist_ok=True)

NEMAR_PADDING_LENGTH_SECONDS = 5
SAMPLING_FREQUENCY_HZ = 500
NEMAR_PADDING_LENGTH_SAMPLES = NEMAR_PADDING_LENGTH_SECONDS * SAMPLING_FREQUENCY_HZ
EPOCH_LENGTH_SECONDS = 12
EPOCH_LENGTH_SAMPLES = int(EPOCH_LENGTH_SECONDS * SAMPLING_FREQUENCY_HZ)
N_CHANNELS = 19
N_SUBJECTS = 88
N_EPOCHS = 12 #12 samples per recording
N_SEGMENTS = 21
SEGMENT_LENGTH_SAMPLES = 2 * SAMPLING_FREQUENCY_HZ
OVERLAP_SECONDS = 1.5  # 1.5s overlap
OVERLAP_SAMPLES = int(OVERLAP_SECONDS * SAMPLING_FREQUENCY_HZ)
ALPHA_FREQUENCIES = (4, 8, 0.1)
GAMMA_FREQUENCIES = (15, 120, 1)
CWT_B = 6
CWT_C = 0.8125
N_PHASE_BINS = 18


# Function definitions
def get_subject_group(subject_str):
    participant_id = "sub-" + subject_str
    participants_df = pd.read_csv(LABEL_PATH, sep="\t")
    participant_row = participants_df[participants_df['participant_id'] == participant_id]
    assert not participant_row.empty, f"Participant ID {participant_id} not found in label file."
    return participant_row['Group'].values[0]

def get_cwt_scales(min_freq, max_freq, step_size):
    frequencies = np.arange(min_freq, max_freq, step_size)
    scales = 1 / (frequencies * (1 / SAMPLING_FREQUENCY_HZ))
    return scales

def apply_notch_filter(signal, fs, freq=60, quality_factor=30):
    b, a = iirnotch(freq, quality_factor, fs)
    return filtfilt(b, a, signal)

def apply_cwt(signal, scales, wavelet_name='cmor'):
    coeffs, frequencies = pywt.cwt(signal, scales, wavelet_name, sampling_period=1 / SAMPLING_FREQUENCY_HZ)
    return coeffs, frequencies

def extract_phase_amplitude(coeffs):
    phase = np.angle(coeffs)
    amplitude = np.abs(coeffs)
    return phase, amplitude

def calculate_pac(theta_phase, gamma_amplitude, nbins=18):
    phase_bins = np.linspace(-np.pi, np.pi, nbins + 1)
    bin_indices = np.digitize(theta_phase, phase_bins) - 1
    amplitude_means = np.zeros(nbins)
    for i in range(nbins):
        bin_amplitudes = gamma_amplitude[bin_indices == i]
        amplitude_means[i] = np.mean(bin_amplitudes) if bin_amplitudes.size > 0 else 0
    amplitude_prob_dist = amplitude_means / np.sum(amplitude_means)
    return amplitude_prob_dist

def calculate_modulation_index(pac_distribution):
    H = -np.sum(pac_distribution * np.log(pac_distribution + 1e-8))
    H_max = np.log(len(pac_distribution))
    return (H_max - H) / H_max

# Main processing function
def generate_gpac_and_save():
    alpha_scales = get_cwt_scales(ALPHA_FREQUENCIES[0], ALPHA_FREQUENCIES[1], ALPHA_FREQUENCIES[2])
    gamma_scales = get_cwt_scales(GAMMA_FREQUENCIES[0], GAMMA_FREQUENCIES[1], GAMMA_FREQUENCIES[2])
    cwt_scales = np.concatenate((alpha_scales, gamma_scales))

    for subject_id in range(1, N_SUBJECTS + 1):  # Process all subjects
        subject_str = f"{subject_id:03}"
        try:
            subject_group = get_subject_group(subject_str)
            if subject_group == "F":  # Skip FTD group
                continue

            label = "cn" if subject_group == "C" else "ad"
            subject_path = f"{DATA_PATH}/sub-{subject_str}/eeg/sub-{subject_str}_task-eyesclosed_eeg.set"
            json_path = f"{DATA_PATH}/sub-{subject_str}/eeg/sub-{subject_str}_task-eyesclosed_eeg.json"
            subject_raw = mne.io.read_raw_eeglab(subject_path, preload=True)
            subject_data = subject_raw.get_data()

            with open(json_path, 'r') as json_file:
                recording_duration = json.load(json_file).get("RecordingDuration")
            assert subject_data.shape == (N_CHANNELS, int(SAMPLING_FREQUENCY_HZ * recording_duration))

            d_epoch_start_time_sec = (recording_duration - 2 * NEMAR_PADDING_LENGTH_SECONDS - EPOCH_LENGTH_SECONDS) / (N_EPOCHS - 1)
            d_epoch_start_time_sample = int(d_epoch_start_time_sec * SAMPLING_FREQUENCY_HZ)

            for epoch_id in range(N_EPOCHS):
                start_sample = NEMAR_PADDING_LENGTH_SAMPLES + epoch_id * d_epoch_start_time_sample
                epoch = subject_data[:, start_sample: (start_sample + EPOCH_LENGTH_SAMPLES)]

                for segment_id in range(N_SEGMENTS):
                    start_sample = segment_id * (SEGMENT_LENGTH_SAMPLES - OVERLAP_SAMPLES)
                    end_sample = start_sample + SEGMENT_LENGTH_SAMPLES
                    segment = epoch[:, start_sample:end_sample]

                    pac_matrix = np.zeros((len(alpha_scales), len(gamma_scales)))

                    for channel_id in range(N_CHANNELS):
                        segment_channel = segment[channel_id, :]
                        coefs, _ = apply_cwt(segment_channel, cwt_scales, f"cmor{CWT_B}-{CWT_C}")
                        alpha_coefs = coefs[:len(alpha_scales), :]
                        gamma_coefs = coefs[len(alpha_scales):, :]

                        alpha_phase, _ = extract_phase_amplitude(alpha_coefs)
                        _, gamma_amplitude = extract_phase_amplitude(gamma_coefs)

                        for a_idx, theta_phase in enumerate(alpha_phase):
                            for g_idx, gamma_amp in enumerate(gamma_amplitude):
                                pac_dist = calculate_pac(theta_phase, gamma_amp)
                                pac_matrix[a_idx, g_idx] += calculate_modulation_index(pac_dist)

                    pac_matrix /= N_CHANNELS

                    # Save PAC plot
                    plt.figure(figsize=(8, 6))
                    plt.imshow(
                        pac_matrix,
                        aspect='auto',
                        origin='lower',
                        cmap='viridis',
                        extent=[ALPHA_FREQUENCIES[0], ALPHA_FREQUENCIES[1], GAMMA_FREQUENCIES[0], GAMMA_FREQUENCIES[1]]
                    )
                    plt.colorbar(label='PAC Modulation Index')
                    plt.title(f"PAC Matrix for Subject {subject_str} - {label}")
                    plt.xlabel("Theta Phase Frequencies (Hz)")
                    plt.ylabel("Gamma Amplitude Frequencies (Hz)")
                    plot_save_path = f"{SAVE_PATH_PNG}/cfc_{subject_str}_{label}_epoch-{epoch_id}_segment-{segment_id}.png"
                    plt.savefig(plot_save_path)
                    plt.close()

        except Exception as e:
            print(f"Error processing subject {subject_str}: {e}")

# Run the main function
generate_gpac_and_save()

import numpy as np
import matplotlib.pyplot as plt

def generate_synthetic_signal(
    sampling_frequency,
    duration_seconds,
    alpha_frequency,
    gamma_frequency,
    modulation_depth=0.5
):
    """
    Generate a synthetic EEG-like signal with PAC.

    Parameters:
    - sampling_frequency: int, Sampling frequency in Hz.
    - duration_seconds: float, Duration of the signal in seconds.
    - alpha_frequency: float, Frequency of the low-frequency phase component in Hz.
    - gamma_frequency: float, Frequency of the high-frequency amplitude component in Hz.
    - modulation_depth: float, Amplitude modulation depth (0 to 1).

    Returns:
    - signal: np.ndarray, Generated synthetic signal.
    """
    t = np.linspace(0, duration_seconds, int(sampling_frequency * duration_seconds), endpoint=False)

    # Generate alpha phase signal
    alpha_phase = np.sin(2 * np.pi * alpha_frequency * t)

    # Modulate gamma amplitude
    gamma_carrier = np.sin(2 * np.pi * gamma_frequency * t)
    modulated_gamma = (1 + modulation_depth * alpha_phase) * gamma_carrier

    return modulated_gamma


def verify_cfc_script():
    # Synthetic signal parameters
    duration = 2  # seconds
    sampling_frequency = SAMPLING_FREQUENCY_HZ  # 500 Hz
    alpha_frequency = 6  # Hz (in the alpha band)
    gamma_frequency = 80  # Hz (in the gamma band)
    modulation_depth = 0.5  # Depth of amplitude modulation

    # Generate synthetic EEG-like signal
    synthetic_signal = generate_synthetic_signal(
        sampling_frequency, duration, alpha_frequency, gamma_frequency, modulation_depth
    )

    # Plot the synthetic signal
    plt.figure(figsize=(10, 4))
    plt.plot(np.linspace(0, duration, len(synthetic_signal)), synthetic_signal)
    plt.title("Synthetic EEG-like Signal with PAC")
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude")
    plt.grid(True)
    plt.show()

    # Compute CWT scales for alpha and gamma bands
    alpha_scales = get_cwt_scales(ALPHA_FREQUENCIES[0], ALPHA_FREQUENCIES[1], ALPHA_FREQUENCIES[2])
    gamma_scales = get_cwt_scales(GAMMA_FREQUENCIES[0], GAMMA_FREQUENCIES[1], GAMMA_FREQUENCIES[2])

    # Apply CWT to extract coefficients
    alpha_coefs, _ = apply_cwt(synthetic_signal, alpha_scales, wavelet_name=f"cmor{CWT_B}-{CWT_C}")
    gamma_coefs, _ = apply_cwt(synthetic_signal, gamma_scales, wavelet_name=f"cmor{CWT_B}-{CWT_C}")

    # Extract phases (alpha) and amplitudes (gamma)
    alpha_phase, _ = extract_phase_amplitude(alpha_coefs)
    _, gamma_amplitude = extract_phase_amplitude(gamma_coefs)

    # Ensure both arrays have the same time dimension
    min_time_points = min(alpha_phase.shape[1], gamma_amplitude.shape[1])
    alpha_phase = alpha_phase[:, :min_time_points]
    gamma_amplitude = gamma_amplitude[:, :min_time_points]

    # Initialize PAC matrix
    pac_matrix = np.zeros((len(alpha_scales), len(gamma_scales)))

    # Calculate PAC matrix
    for a_idx, theta_phase in enumerate(alpha_phase):
        for g_idx, gamma_amp in enumerate(gamma_amplitude):
            pac_dist = calculate_pac(theta_phase, gamma_amp)
            pac_matrix[a_idx, g_idx] = calculate_modulation_index(pac_dist)

    # Flip PAC matrix for proper visualization
    flipped_pac_matrix = np.flip(pac_matrix.T, axis=0)

    # Plot PAC matrix
    plt.figure(figsize=(8, 6))
    plt.imshow(
        flipped_pac_matrix,
        extent=[ALPHA_FREQUENCIES[0], ALPHA_FREQUENCIES[1], GAMMA_FREQUENCIES[0], GAMMA_FREQUENCIES[1]],
        aspect='auto',
        origin='lower',
        cmap='viridis'
    )
    plt.colorbar(label="PAC Modulation Index")
    plt.title("PAC Matrix - Synthetic Signal")
    plt.xlabel("Theta Phase Frequency (Hz)")
    plt.ylabel("Gamma Amplitude Frequency (Hz)")
    plt.show()

    # Plot phases and amplitudes
    plot_phases_and_amplitudes(alpha_phase, gamma_amplitude, alpha_scales, gamma_scales)

    print("CFC script verification complete.")

# Call the verification function
verify_cfc_script()